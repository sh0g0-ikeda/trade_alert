# 7. 非機能要件

非機能要件は、プロダクトの品質・可用性・安全性を保証するための技術的条件を定義する。
アプリの性質上、リアルタイム性よりも「安定稼働」「コスト最適化」「ユーザー情報の安全性」を重視する。

---

## 7.1 可用性（Availability）

### **7.1.1 稼働時間の目標値**

* APIサーバー、価格取得ジョブ、通知ジョブの **年間稼働率99%以上**
* システム停止時の影響は限定的（遅延通知になる程度）だが、

  * **ダウンは最大でも数時間以内に復旧できる構成**で運用する。

### **7.1.2 デプロイ時の影響**

* Serverless（Lambda）想定のため、デプロイ中のダウンタイムは原則ゼロ
* API Gatewayによるルーティング切替で瞬断を避ける

### **7.1.3 障害発生時**

* バッチが失敗した場合：

  * 次のジョブ起動時に再実行される
  * 連続失敗が発生すれば開発者にアラート通知

---

## 7.2 パフォーマンス（Performance）

### **7.2.1 レイテンシ要件**

* ユーザー操作に対するAPI応答時間：

  * **平均200〜500ms以下**
* バックエンドのバッチ処理は数秒〜数十秒かかっても問題なし
  （ユーザーが待つ画面ではないため）

### **7.2.2 スループット**

* ユーザー数 1,000人（ユニーク300銘柄）でも、

  * 価格取得ジョブ：最大500〜600コール/月 → 問題なし
* 通知ジョブは1回あたり最大数百件程度 → APNs/FCMが処理できる範囲

### **7.2.3 スケーリング**

* Lambda が自動スケールするため、APIトラフィック増加は問題なし
* ボトルネックは以下に集中：

  * 外部APIの呼び出し回数（Marketstack等）
  * PriceCache の更新（1 job あたり数百レコード）
* ユニーク銘柄数が増えすぎた場合：

  * アプリ側で「未対応銘柄」を設定して API負荷を抑制

---

## 7.3 セキュリティ（Security）

### **7.3.1 認証・認可**

* JWT または セッション管理で access_token を発行
* `password_hash` は bcrypt 等の強固なハッシュで保存
* 全通信は HTTPS（TLS1.2+）

### **7.3.2 データ保護**

* 取得単価など**個人資産情報はサーバーに保存しない**設計が望ましい
  （必須でない限り）
* 保存するデータは銘柄・基準価格・通知履歴など軽量なもののみ

### **7.3.3 スクショ画像の取り扱い**

* スクショは S3 に**一時的に保存**
* Vision API 解析完了後：

  * **即時削除**
  * S3 Lifecycle でも 1日以内に自動削除設定を入れる
* 顔・名前・口座番号などが写る可能性があるため、

  * アップロード前にクライアントで自動マスク処理を実装（推奨）

### **7.3.4 APIキー保護**

* 外部APIキーは Lambda の環境変数 or SecretsManager に暗号化保存
* クライアントに APIキーを一切渡さない

---

## 7.4 信頼性（Reliability）

### **7.4.1 エラーの扱い**

* Price APIがエラーの場合

  * その銘柄のチェックはスキップ
  * 連続エラー3回以上なら開発者へ通知
* 通知失敗：

  * APNs/FCM のレスポンスコードで再送/無効化判定

### **7.4.2 データの整合性**

* `UserAssetSettings.last_notified_price` は通知時にのみ更新
* 価格の履歴は保持しない（必要ないため）

### **7.4.3 ログ**

* 以下は CloudWatch へ記録：

  * 外部API呼び出し成功/失敗
  * バッチ開始・終了・エラー
  * 通知送信結果
  * サブスク検証成功/失敗

---

## 7.5 メンテナンス性（Maintainability）

### **7.5.1 コード分割**

* 価格取得ロジックは asset_class ごとにサービス化（stock/crypto/fx/commodity）
* 判定ロジックは共通関数として切り出し

### **7.5.2 環境の分離**

* `dev` / `staging` / `prod` を分離
* ストアのサブスク検証は sandbox を用意

### **7.5.3 バージョン管理**

* APIはバージョン付き（例：`/v1/user/assets`）
* 後方互換性を維持する（クライアントの古いバージョンが壊れないように）

---

## 7.6 運用（Operations）

### **7.6.1 モニタリング**

最低限、以下のメトリクスを可視化：

* APIエラー率
* 外部APIの429 / timeout率
* PriceCache の更新回数
* 通知送信件数
* 有料ユーザー数の推移

### **7.6.2 アラート設定（開発者向け）**

* Price API連続失敗 → Slack/LINE通知
* 通知送信失敗率が一定値を超えた場合 → アラート
* 有料ユーザーのレシート検証失敗 → アラート

---

## 7.7 障害復旧（Recovery）

### **7.7.1 バックアップ**

* DynamoDB は PITR（Point-In-Time Recovery）を有効化
* バックアップ費用は小額（数十円〜数百円）

### **7.7.2 復旧シナリオ**

* PriceCache復旧不要（バッチで再取得）
* UserAssetSettings/Users はバックアップから復元可能

### **7.7.3 依存サービス障害時の動作**

* MarketstackやCoinGeckoが落ちた場合

  * その回はスキップして次回へ
  * ユーザー通知は行わない（通知欠落は許容）

---

## 7.8 コスト最適化（Cost Optimization）

### **7.8.1 APIコール数最適化**

* ユニーク銘柄集約でコール数を最小化
* まとめ取得エンドポイント（symbols=batch形式）を活用する

### **7.8.2 Lambda**

* メモリは最小構成（128MB〜256MB）で十分
* 実行時間短縮よりもコスト低減を優先する

### **7.8.3 DynamoDB**

* キャパシティはオンデマンドでOK（スパイクを吸収）

### **7.8.4 スクショ解析**

* ファイル保持は最短（即削除）
* Vision APIへのリクエスト数も月数十〜百回レベル

---

## 7.9 スケーラビリティ（Scalability）

### **7.9.1 ユーザー増加に対して**

* APIトラフィック：Lambdaが自動スケール
* 銘柄設定：数千ユーザーでも DynamoDB で余裕
* 最大負荷は「ユニーク銘柄 × ジョブ回数」だが、

  * 実質500銘柄まで増えても Marketstack Proで処理可能

### **7.9.2 将来的なマイクロサービス化**

必要に応じて：

* price-service
* alert-service
* user-service

に分割できる構成を意識する（ただしMVPでは不要）

---

## 7.10 ユーザー体験（UX）に影響する非機能要件

### **7.10.1 通知遅延**

* ±5分〜±10分の遅延は許容される（バッチ方式のため）
* 1時間以上の遅延はバグとして扱う

### **7.10.2 ページ表示速度**

* 銘柄一覧画面は PriceCache を直接返すため

  * 平均200〜300msで表示完了
* スクロールするほどの巨大リストにはならない（上限制御済）

### **7.10.3 プッシュ通知欠落**

* モバイルOS側が一定割合で通知を落とす可能性はある
* ユーザーにはヘルプに「OSの電池最適化無効化を推奨」と記載
